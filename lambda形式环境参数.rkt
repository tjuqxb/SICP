
;由替换模型向约束模型的转变。 约束模型：以LAMBDA表达式为基础，引进实参时，产生新的环境及本层约束，内部在包含本层约束的新环境中求值。
;确定同一性的方法
;                          (define q (m a))
;q被约束到了求值结果(m a)上
;若 (define(q x)) 是一个语法糖衣
;(define (q x)(proc x))
;(define q (lambda (x) (proc x)))
;q被约束到了(lambda(x) (proc x))这一约束上
;

;                          (let ((q (m x)))
;每一次代换形式参数实际参数都会产生一个新环境，用DEFINE将符号约束到这个新环境上保证引用的同一性，同一性即是在同一个环境下。最外层环境约束E1
;let内部对q的引用一定是同一个对象，字母q 被限制到引用(m x)所产生的一个特定环境上,产生了新的环境约束E2
;每一个函数均在一定的环境约束下起作用，在一个约束下定义一个函数，可以用SET!改变外层的约束指针，而在本层函数内部直接采用SET!改变
;的结果是改变本层在引进实际参数时产生的约束
;由于在引用本层函数时，会对实参重新赋值，所以此次改变本层参数在下一次引用时，又会改变一次，即使保证对象的同一性，也无法记录上次结果。
;引用内层函数可以通过SET!改变外层环境约束的指针，并直接反映出结果，并记录。所以保存或提取值的方法一般是定义两层或以上的函数，通过调用
;同一外层对象约束下的内层函数
;改变外层函数的约束值。

(define (k x)
  (let ((m 1) (n 1))
    (lambda()
      (set! m (+ m n))
      m)))

(define (k1 x)
  (let ((m 1) (n 1))
    (set! m (+ m n))
    m))

(define (k2 x)
  (let ((m 1) (n 1))
    (define (z)
    (set! m (+ m n))
      m)
    z))

(define q
  (cons 1
        (k 1)))

(cdr q) ;单纯的(cdr q)返回(k 1);一个匿名函数

((cdr q));调用函数改变环境变量

((cdr q));可以多次调用，证明是同一个对象


(define s (k 1))

(define s1 (k1 1))

(define s2 (k2 1))

(s)

(s)

s1

s1

(s2)

(s2)